# Kubernetes Prompts & Manifests Portfolio

This repository contains a portfolio of **prompt-engineering instructions** (designed to work well with tools like `kubectl-ai`) and the **resulting Kubernetes YAML manifests**.  
Each prompt is written in English and follows good prompt-engineering practices (explicit role, constraints, validation steps).

> Tip: Copy a prompt from the table and paste it into your AI assistant (e.g., `kubectl ai --generate -f -`) to generate or analyze manifests. The **EXAMPLE** column links to the manifest in `./yaml` at the repo root.

| NAME | PROMPT | DESCRIPTION | EXAMPLE |
|---|---|---|---|
| app.yaml | **Role:** You are a Kubernetes expert generating production-ready YAML. **Task:** Create a basic web app **Deployment** (3 replicas) and a **ClusterIP Service** exposing port 80. **Image:** `nginxdemos/hello:latest`. **Labels:** `app=go-demo-app`. **Namespace:** `default`. **Constraints:** use `apps/v1` for Deployment, set `selector.matchLabels` to match `template.metadata.labels`, add a rolling update strategy, set `imagePullPolicy: IfNotPresent`. **Validation:** ensure the Service targets the Pod port and label selector matches. **Output:** a single multi-doc YAML separated by `---`, with comments explaining non-obvious fields. **Also include** a short “How to apply & test” comment block at the end. | Baseline app and service to review structure. | [./yaml/app.yaml](./yaml/app.yaml) |
| app-livenessProbe.yaml | **Role:** Kubernetes SRE. **Task:** Add an **HTTP livenessProbe** to a Deployment serving on `/` port `80`. **InitialDelay:** 10s, **timeoutSeconds:** 2, **periodSeconds:** 10, **failureThreshold:** 3. **Constraints:** keep spec minimal; place the probe under the container. **Validation:** probe path and port exist. **Output:** standalone Deployment manifest. **Explain (comments)** when this would restart the container. | Demonstrates basic liveness health-check. | [./yaml/app-livenessProbe.yaml](./yaml/app-livenessProbe.yaml) |
| app-readinessProbe.yaml | **Role:** Platform engineer. **Task:** Add an **HTTP readinessProbe** to gate traffic until the app is ready. Path `/readyz`, port `80`, `initialDelaySeconds: 5`, `periodSeconds: 5`, `successThreshold: 1`, `failureThreshold: 3`. **Constraints:** do not include Service; focus on readiness semantics. **Validation:** ensure `readinessProbe` is independent from liveness. **Output:** Deployment manifest with comments. | Shows traffic gating using readiness. | [./yaml/app-readinessProbe.yaml](./yaml/app-readinessProbe.yaml) |
| app-volumeMounts.yaml | **Role:** Kubernetes architect. **Task:** Define a Deployment that mounts an **emptyDir** at `/usr/share/nginx/html/data` and a **ConfigMap** at `/etc/app-config` (read-only). **Constraints:** include both `volumes` and `volumeMounts`; add an initContainer that writes a file into the emptyDir. **Validation:** mounts must exist and be non-conflicting. **Output:** Deployment + ConfigMap in a single multi-doc file. | Shows ephemeral storage & config injection. | [./yaml/app-volumeMounts.yaml](./yaml/app-volumeMounts.yaml) |
| app-cronjob.yaml | **Role:** Kubernetes batch expert. **Task:** Create a **CronJob** that runs every 5 minutes to call `https://example.com/health` with `curl -fsS` and exits non‑zero on failure. **Constraints:** `batch/v1`, `concurrencyPolicy: Forbid`, `successfulJobsHistoryLimit: 3`, `failedJobsHistoryLimit: 1`, `backoffLimit: 0`, `ttlSecondsAfterFinished: 60`. **Validation:** container must have `curl` (use `curlimages/curl`). **Output:** CronJob manifest with comments. | Scheduled health ping example. | [./yaml/app-cronjob.yaml](./yaml/app-cronjob.yaml) |
| app-job.yaml | **Role:** Kubernetes batch engineer. **Task:** Create a **Job** that prints “data migration complete” and exits 0. **Constraints:** `restartPolicy: Never`, `backoffLimit: 1`, resource requests minimal. **Validation:** ensure termination and no infinite restarts. **Output:** Job manifest. | One-off batch job. | [./yaml/app-job.yaml](./yaml/app-job.yaml) |
| app-multicontainer.yaml | **Role:** Sidecar pattern specialist. **Task:** Create a **Deployment** with two containers: (1) app `nginxdemos/hello` serving 80; (2) sidecar `busybox` that tails `/var/log/app/access.log`. **Shared volume:** `emptyDir` mounted at `/var/log/app`. App should write access logs to that path (use nginx env or command to log there). **Constraints:** include lifecycle preStop sleep 5s on both. **Validation:** both containers run and share the volume; probes optional. **Output:** Deployment manifest with comments. | Demonstrates the sidecar logging pattern. | [./yaml/app-multicontainer.yaml](./yaml/app-multicontainer.yaml) |
| app-resources.yaml | **Role:** Performance-conscious DevOps. **Task:** Add **resources** to the Deployment: requests `100m` CPU / `128Mi` memory; limits `500m` / `256Mi`. **Constraints:** include `topologySpreadConstraints` across zones on label `topology.kubernetes.io/zone` with `maxSkew: 1`. **Validation:** ensure selectors match; include comments explaining trade-offs. **Output:** Deployment manifest with resources & scheduling hints. | Shows resource sizing + scheduling. | [./yaml/app-resources.yaml](./yaml/app-resources.yaml) |
| app-secret-env.yaml | **Role:** Security-minded SRE. **Task:** Create a **Secret** named `app-secret` with keys `API_KEY` and `DB_PASSWORD` (dummy base64 values), and a **Deployment** that imports them via `envFrom.secretRef`. The app prints the presence (not the values) of these vars on start. **Constraints:** set `envFrom` (not individual `env`), add a `securityContext` (runAsNonRoot, readOnlyRootFilesystem). **Validation:** secret and deployment in same namespace; avoid exposing secrets in logs. **Output:** multi-doc YAML. | Securely passing env via Secret. | [./yaml/app-secret-env.yaml](./yaml/app-secret-env.yaml) |

## How this portfolio was authored

- Prompts follow Google’s prompt-engineering guidance: clear role, constraints, and requested output with validation checks and comments.
- Intended to be used with tools like [`kubectl-ai`](https://github.com/GoogleCloudPlatform/kubectl-ai).
- Manifests are intentionally simple yet production-leaning for clarity.
